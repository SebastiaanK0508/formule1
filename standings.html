<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Formula 1 Season 2025 - Drivers</title>
    <link rel="stylesheet" href="style.css">
    <style>
        #f1-standings-container table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        #f1-standings-container th, #f1-standings-container td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        #f1-standings-container th {
            background-color: #f2f2f2;
        }
        #f1-standings-container h2 {
            margin-top: 30px;
            font-size: 1.5em;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content container">
            <h1 class="site-title">Formula 1 Season 2025</h1>
            <nav class="main-nav">
                <a href="index.php">Home</a>
                <a href="kalender.html">Schedule</a>
                <a href="teams.php" >Teams</a>
                <a href="drivers.php">Drivers</a>
                <a href="standings.html" class="active">Standings</a>
            </nav>
        </div>
    </header>

<main id="f1-standings-container" class="container">
    <h2>F1 Race result</h2>    
    <div>
        <a href="">
            <div>
                <h2>Australian Grand Prix</h2>
            </div>
        </a>
    </div>
</main>
<!--<script>
async function loadF1Standings() {
    const container = document.getElementById('f1-standings-container');
    container.innerHTML = '<p>Laden van F1 klassement...</p>'; // Loading message

    try {
        // --- Fetch Driver Standings from OpenF1 API ---
        // OpenF1 API provides "driver_standings" and "constructor_standings" directly.
        // You generally need to specify the `meeting_key` or `session_key` for the latest event.
        // For simplicity, we'll try to get the latest standings for the current year.
        // OpenF1's "standings" endpoint provides both driver and constructor standings.

        const currentYear = new Date().getFullYear(); // Get the current year
        const driverStandingsResponse = await fetch(`https://api.openf1.org/v1/drivers?session_key=latest`);
        if (!driverStandingsResponse.ok) {
            throw new Error(`HTTP error! status: ${driverStandingsResponse.status}`);
        }
        const driversData = await driverStandingsResponse.json();

        const constructorStandingsResponse = await fetch(`https://api.openf1.org/v1/constructors?session_key=latest`);
        if (!constructorStandingsResponse.ok) {
            throw new Error(`HTTP error! status: ${constructorStandingsResponse.status}`);
        }
        const constructorsData = await constructorStandingsResponse.json();

        // For actual standings, you'd typically query the /v1/standings endpoint.
        // Let's refine this to get actual standings directly.

        const standingsResponse = await fetch(`https://api.openf1.org/v1/drivers?session_key=latest&driver_number=*`);
        if (!standingsResponse.ok) {
            throw new Error(`HTTP error! status: ${standingsResponse.status}`);
        }
        const standingsData = await standingsResponse.json();

        // Filter for drivers who have a position and points (meaning they are in the standings)
        const driverStandings = standingsData.filter(driver => driver.standing_position && driver.points_total)
                                            .sort((a, b) => a.standing_position - b.standing_position);


        let tableHTML = '<h2>F1 Coureurs Kampioenschap</h2>';
        if (driverStandings.length > 0) {
            tableHTML += '<table>';
            tableHTML += '<thead><tr><th>Pos</th><th>Coureur</th><th>Team</th><th>Punten</th></tr></thead>';
            tableHTML += '<tbody>';

            driverStandings.forEach(driver => {
                // OpenF1 provides driver details directly, including the team (constructor_name)
                tableHTML += `
                    <tr>
                        <td>${driver.standing_position}</td>
                        <td>${driver.full_name}</td>
                        <td>${driver.constructor_name}</td>
                        <td>${driver.points_total}</td>
                    </tr>
                `;
            });
            tableHTML += '</tbody></table>';
        } else {
            tableHTML += '<p>Geen coureurs klassement data beschikbaar op dit moment voor de laatste sessie.</p>';
        }

        // --- Fetch Constructor Standings from OpenF1 API ---
        // OpenF1 doesn't have a direct /constructorStandings endpoint like Ergast.
        // Instead, you'd typically aggregate points from drivers of the same constructor,
        // or look for a specific 'constructor_standings' field within a more general
        // standings endpoint if one exists and is documented.
        // For simplicity, let's assume we can derive constructor standings from driver data if not available directly.
        // However, OpenF1 *does* have a `/v1/constructors` endpoint with some info.
        // To get points for constructors, you'd need to sum the points of their drivers from the driver standings.

        // A more robust way to get constructor standings would be to query the `/v1/standings` endpoint
        // if it provided constructor-specific total points directly, or sum from driver data.
        // Let's use the fetched driver data to calculate constructor points for demonstration.

        const constructorPointsMap = {};
        driverStandings.forEach(driver => {
            const teamName = driver.constructor_name;
            const points = driver.points_total;
            if (constructorPointsMap[teamName]) {
                constructorPointsMap[teamName] += points;
            } else {
                constructorPointsMap[teamName] = points;
            }
        });

        const calculatedConstructorStandings = Object.entries(constructorPointsMap)
            .map(([name, points]) => ({ name, points }))
            .sort((a, b) => b.points - a.points); // Sort by points in descending order

        tableHTML += '<h2>F1 Constructeurs Kampioenschap</h2>';
        if (calculatedConstructorStandings.length > 0) {
            tableHTML += '<table>';
            tableHTML += '<thead><tr><th>Pos</th><th>Team</th><th>Punten</th></tr></thead>';
            tableHTML += '<tbody>';

            calculatedConstructorStandings.forEach((constructor, index) => {
                tableHTML += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${constructor.name}</td>
                        <td>${constructor.points}</td>
                    </tr>
                `;
            });
            tableHTML += '</tbody></table>';
        } else {
            tableHTML += '<p>Geen constructeurs klassement data beschikbaar op dit moment.</p>';
        }


        container.innerHTML = tableHTML;

    } catch (error) {
        console.error('Fout bij ophalen F1 klassement:', error);
        container.innerHTML = '<p>Er is een probleem opgetreden bij het laden van het klassement. Probeer het later opnieuw.</p>';
    }
}

// Call the function when the page is loaded
document.addEventListener('DOMContentLoaded', loadF1Standings);
</script>-->
</body>
</html>